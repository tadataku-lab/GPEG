[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial source changes: [0m
[0m[[0m[0mdebug[0m] [0m[0m	removed:Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	added: Set(/Users/shonanking/lab/GPEG/src/main/scala/Tree.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	modified: Set(/Users/shonanking/lab/GPEG/src/main/scala/PegPackratParser.scala, /Users/shonanking/lab/GPEG/src/main/scala/PegParser.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated products: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mExternal API changes: API Changes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mModified binary dependencies: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial directly invalidated classes: Set(AmbNode, PegPackratParser.AmbContext, PegPackratParser.ParseResult, PegParser, PegPackratParser.Left, PegPackratParser, PegPackratParser.Right, Tree, Node, Leaf, PegPackratParser.LorRorB, PegPackratParser.ContextTree, PegParser.ParserContext, PegPackratParser.AmbParseResult, PegPackratParser.Memo, PegPackratParser.Both, PegPackratParser.ParserContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mSources indirectly invalidated by:[0m
[0m[[0m[0mdebug[0m] [0m[0m	product: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	binary dep: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	external source: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated classes: Set(AmbNode, PegPackratParser.AmbContext, PegPackratParser.ParseResult, PegParser, PegPackratParser.Left, PegPackratParser, PegPackratParser.Right, Tree, Node, Leaf, PegPackratParser.LorRorB, PegPackratParser.ContextTree, PegParser.ParserContext, PegPackratParser.AmbParseResult, PegPackratParser.Memo, PegPackratParser.Both, PegPackratParser.ParserContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated sources:Set(/Users/shonanking/lab/GPEG/src/main/scala/Tree.scala, /Users/shonanking/lab/GPEG/src/main/scala/PegPackratParser.scala, /Users/shonanking/lab/GPEG/src/main/scala/PegParser.scala)[0m
[0m[[0m[0minfo[0m] [0m[0mCompiling 3 Scala sources to /Users/shonanking/lab/GPEG/target/scala-2.12/classes ...[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.12:1.0.5:compile for Scala 2.12.4[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.12:1.0.5:compile for Scala 2.12.4[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] Running cached compiler 65e83d68 for Scala compiler version 2.12.4[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] The Scala compiler is invoked with:[0m
[0m[[0m[0mdebug[0m] [0m[0m	-deprecation[0m
[0m[[0m[0mdebug[0m] [0m[0m	-feature[0m
[0m[[0m[0mdebug[0m] [0m[0m	-unchecked[0m
[0m[[0m[0mdebug[0m] [0m[0m	-Xlint[0m
[0m[[0m[0mdebug[0m] [0m[0m	-bootclasspath[0m
[0m[[0m[0mdebug[0m] [0m[0m	/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/sunrsasign.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/classes:/Users/shonanking/.sbt/boot/scala-2.12.4/lib/scala-library.jar[0m
[0m[[0m[0mdebug[0m] [0m[0m	-classpath[0m
[0m[[0m[0mdebug[0m] [0m[0m	/Users/shonanking/lab/GPEG/target/scala-2.12/classes:/Users/shonanking/.ivy2/cache/org.scalactic/scalactic_2.12/bundles/scalactic_2.12-3.0.4.jar:/Users/shonanking/.sbt/boot/scala-2.12.4/lib/scala-reflect.jar:/Users/shonanking/.ivy2/cache/org.scala-lang.modules/scala-parser-combinators_2.12/bundles/scala-parser-combinators_2.12-1.0.6.jar[0m
[0m[[0m[0mdebug[0m] [0m[0mScala compilation took 9.518580369 s[0m
[0m[[0m[0minfo[0m] [0m[0mDone compiling.[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Leaf...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Leaf)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Leaf)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Leaf,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(copy$default$1,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(productPrefix,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(productIterator,[Default]), UsedName(getClass,[Default]), UsedName(canEqual,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(equals,[Default]), UsedName(Leaf,[Default]), UsedName(v,[Default]), UsedName($isInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(productElement,[Default]), UsedName(Leaf;init;,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]))) invalidates 1 classes due to The Leaf has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(asInstanceOf,[Default]), UsedName(copy$default$1,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(productPrefix,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(productIterator,[Default]), UsedName(getClass,[Default]), UsedName(canEqual,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(equals,[Default]), UsedName(Leaf,[Default]), UsedName(v,[Default]), UsedName($isInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(productElement,[Default]), UsedName(Leaf;init;,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Leaf)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Node...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Node)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Node)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Node,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(productPrefix,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(productIterator,[Default]), UsedName(getClass,[Default]), UsedName(Node;init;,[Default]), UsedName(canEqual,[Default]), UsedName(next,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(equals,[Default]), UsedName(Node,[Default]), UsedName($isInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(productElement,[Default]), UsedName(==,[Default]), UsedName(name,[Default]), UsedName(finalize,[Default]))) invalidates 1 classes due to The Node has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(productPrefix,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(productIterator,[Default]), UsedName(getClass,[Default]), UsedName(Node;init;,[Default]), UsedName(canEqual,[Default]), UsedName(next,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(equals,[Default]), UsedName(Node,[Default]), UsedName($isInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(productElement,[Default]), UsedName(==,[Default]), UsedName(name,[Default]), UsedName(finalize,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Node)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Tree.Tree...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Tree.Tree)[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding Tree.Node by Tree.Tree[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding Tree.AmbNode by Tree.Tree[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding Tree.Leaf by Tree.Tree[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Tree.AmbNode, Tree.Leaf, Tree.Node, Tree.Tree)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser: Set(UsedName(asInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(Tree,[Default, PatMatTarget]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegParser: Set(UsedName(asInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(Tree,[Default, PatMatTarget]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser: Set(UsedName(asInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(Tree,[Default, PatMatTarget]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegParser: Set(UsedName(asInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(Tree,[Default, PatMatTarget]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser: Set(UsedName(asInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(Tree,[Default, PatMatTarget]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser.ParseResult: Set(UsedName(asInstanceOf,[Default]), UsedName(eq,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(==,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegParser: Set(UsedName(asInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(Tree,[Default, PatMatTarget]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser: Set(UsedName(asInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(Tree,[Default, PatMatTarget]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegParser.ParserContext: Set(UsedName(Tree,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser.AmbParseResult: Set(UsedName(asInstanceOf,[Default]), UsedName(eq,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(==,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser.Memo: Set(UsedName(Tree,[Default]), UsedName(toString,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Tree.Tree,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName(clone,[Default]), UsedName(notify,[Default]), UsedName(ne,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(equals,[Default]), UsedName($isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]))) invalidates 10 classes due to The Tree.Tree has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName(clone,[Default]), UsedName(notify,[Default]), UsedName(ne,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(equals,[Default]), UsedName($isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Tree.AmbNode, Tree.Leaf, Tree.Node, Tree.Tree)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(PegPackratParser.ParseResult, PegParser, PegPackratParser, PegParser.ParserContext, PegPackratParser.AmbParseResult, PegPackratParser.Memo)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from PegParser.ParserContext...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(PegParser.ParserContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(PegParser.ParserContext)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(PegParser.ParserContext,ModifiedNames(changes = UsedName(hash_table,[Default]))) invalidates 1 classes due to The PegParser.ParserContext has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(hash_table,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(PegParser.ParserContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from PegPackratParser.ParseResult...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(PegPackratParser.ParseResult)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(PegPackratParser.ParseResult)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(PegPackratParser.ParseResult,ModifiedNames(changes = UsedName(tupled,[Default]), UsedName(copy$default$1,[Default]), UsedName(curried,[Default]), UsedName(copy,[Default]), UsedName(tree,[Default]), UsedName(ParseResult,[Default]), UsedName(apply,[Default]), UsedName(unapply,[Default]), UsedName(PegPackratParser;ParseResult;init;,[Default]))) invalidates 1 classes due to The PegPackratParser.ParseResult has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(tupled,[Default]), UsedName(copy$default$1,[Default]), UsedName(curried,[Default]), UsedName(copy,[Default]), UsedName(tree,[Default]), UsedName(ParseResult,[Default]), UsedName(apply,[Default]), UsedName(unapply,[Default]), UsedName(PegPackratParser;ParseResult;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(PegPackratParser.ParseResult)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Tree.Node...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Tree.Node)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Tree.Node)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegParser: Set(UsedName(asInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(next,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Node,[Default]), UsedName(apply,[Default]), UsedName(==,[Default]), UsedName(name,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser: Set(UsedName(asInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(next,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(Node,[Default]), UsedName(apply,[Default]), UsedName(==,[Default]), UsedName(name,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Tree.Node,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(tupled,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(productPrefix,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(productIterator,[Default]), UsedName(getClass,[Default]), UsedName(canEqual,[Default]), UsedName(next,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(Tree;Node;init;,[Default]), UsedName(equals,[Default]), UsedName(Node,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(productElement,[Default]), UsedName(unapply,[Default]), UsedName(==,[Default]), UsedName(name,[Default]), UsedName(finalize,[Default]))) invalidates 3 classes due to The Tree.Node has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(asInstanceOf,[Default]), UsedName(tupled,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(productPrefix,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(productIterator,[Default]), UsedName(getClass,[Default]), UsedName(canEqual,[Default]), UsedName(next,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(Tree;Node;init;,[Default]), UsedName(equals,[Default]), UsedName(Node,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(productElement,[Default]), UsedName(unapply,[Default]), UsedName(==,[Default]), UsedName(name,[Default]), UsedName(finalize,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Tree.Node)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(PegParser, PegPackratParser)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from PegPackratParser.Memo...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(PegPackratParser.Memo)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(PegPackratParser.Memo)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(PegPackratParser.Memo,ModifiedNames(changes = UsedName(PegPackratParser;Memo;init;,[Default]), UsedName(tree,[Default]))) invalidates 1 classes due to The PegPackratParser.Memo has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(PegPackratParser;Memo;init;,[Default]), UsedName(tree,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(PegPackratParser.Memo)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from AmbNode...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(AmbNode)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(AmbNode)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(AmbNode,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(AmbNode,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(productPrefix,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(productIterator,[Default]), UsedName(getClass,[Default]), UsedName(lhs,[Default]), UsedName(canEqual,[Default]), UsedName(eq,[Default]), UsedName(copy$default$3,[Default]), UsedName($asInstanceOf,[Default]), UsedName(rhs,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(equals,[Default]), UsedName($isInstanceOf,[Default]), UsedName(id,[Default]), UsedName(productArity,[Default]), UsedName(productElement,[Default]), UsedName(==,[Default]), UsedName(AmbNode;init;,[Default]), UsedName(finalize,[Default]))) invalidates 1 classes due to The AmbNode has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(asInstanceOf,[Default]), UsedName(AmbNode,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(productPrefix,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(productIterator,[Default]), UsedName(getClass,[Default]), UsedName(lhs,[Default]), UsedName(canEqual,[Default]), UsedName(eq,[Default]), UsedName(copy$default$3,[Default]), UsedName($asInstanceOf,[Default]), UsedName(rhs,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(equals,[Default]), UsedName($isInstanceOf,[Default]), UsedName(id,[Default]), UsedName(productArity,[Default]), UsedName(productElement,[Default]), UsedName(==,[Default]), UsedName(AmbNode;init;,[Default]), UsedName(finalize,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(AmbNode)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Tree.AmbNode...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Tree.AmbNode)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Tree.AmbNode)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser: Set(UsedName(asInstanceOf,[Default]), UsedName(AmbNode,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(lhs,[Default]), UsedName(rhs,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(apply,[Default]), UsedName(id,[Default]), UsedName(==,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Tree.AmbNode,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(tupled,[Default]), UsedName(AmbNode,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(productPrefix,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(productIterator,[Default]), UsedName(getClass,[Default]), UsedName(lhs,[Default]), UsedName(canEqual,[Default]), UsedName(eq,[Default]), UsedName(copy$default$3,[Default]), UsedName($asInstanceOf,[Default]), UsedName(rhs,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(Tree;AmbNode;init;,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(id,[Default]), UsedName(productArity,[Default]), UsedName(productElement,[Default]), UsedName(unapply,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]))) invalidates 2 classes due to The Tree.AmbNode has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(asInstanceOf,[Default]), UsedName(tupled,[Default]), UsedName(AmbNode,[Default]), UsedName(copy$default$2,[Default]), UsedName(copy$default$1,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName($init$,[Default]), UsedName(clone,[Default]), UsedName(productPrefix,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(productIterator,[Default]), UsedName(getClass,[Default]), UsedName(lhs,[Default]), UsedName(canEqual,[Default]), UsedName(eq,[Default]), UsedName(copy$default$3,[Default]), UsedName($asInstanceOf,[Default]), UsedName(rhs,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(Tree;AmbNode;init;,[Default]), UsedName(equals,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(id,[Default]), UsedName(productArity,[Default]), UsedName(productElement,[Default]), UsedName(unapply,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Tree.AmbNode)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(PegPackratParser)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Tree.Leaf...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Tree.Leaf)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Tree.Leaf)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegParser: Set(UsedName(asInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Leaf,[Default]), UsedName(apply,[Default]), UsedName(==,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser: Set(UsedName(asInstanceOf,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(Leaf,[Default]), UsedName(apply,[Default]), UsedName(==,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Tree.Leaf,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(copy$default$1,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(clone,[Default]), UsedName(productPrefix,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(compose,[Default]), UsedName(productIterator,[Default]), UsedName(getClass,[Default]), UsedName(Tree;Leaf;init;,[Default]), UsedName(canEqual,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(equals,[Default]), UsedName(Leaf,[Default]), UsedName(v,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(productElement,[Default]), UsedName(unapply,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]))) invalidates 3 classes due to The Tree.Leaf has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(asInstanceOf,[Default]), UsedName(copy$default$1,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(clone,[Default]), UsedName(productPrefix,[Default]), UsedName(notify,[Default]), UsedName(copy,[Default]), UsedName(ne,[Default]), UsedName(compose,[Default]), UsedName(productIterator,[Default]), UsedName(getClass,[Default]), UsedName(Tree;Leaf;init;,[Default]), UsedName(canEqual,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(equals,[Default]), UsedName(Leaf,[Default]), UsedName(v,[Default]), UsedName(apply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(productElement,[Default]), UsedName(unapply,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Tree.Leaf)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(PegParser, PegPackratParser)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from PegPackratParser.AmbParseResult...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(PegPackratParser.AmbParseResult)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(PegPackratParser.AmbParseResult)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(PegPackratParser.AmbParseResult,ModifiedNames(changes = UsedName(tupled,[Default]), UsedName(copy$default$1,[Default]), UsedName(curried,[Default]), UsedName(PegPackratParser;AmbParseResult;init;,[Default]), UsedName(copy,[Default]), UsedName(AmbParseResult,[Default]), UsedName(tree,[Default]), UsedName(apply,[Default]), UsedName(unapply,[Default]))) invalidates 1 classes due to The PegPackratParser.AmbParseResult has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(tupled,[Default]), UsedName(copy$default$1,[Default]), UsedName(curried,[Default]), UsedName(PegPackratParser;AmbParseResult;init;,[Default]), UsedName(copy,[Default]), UsedName(AmbParseResult,[Default]), UsedName(tree,[Default]), UsedName(apply,[Default]), UsedName(unapply,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(PegPackratParser.AmbParseResult)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from PegParser...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(PegParser)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(PegParser)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(PegParser,ModifiedNames(changes = UsedName(many,[Default]), UsedName(peg_parse,[Default]), UsedName(parse,[Default]), UsedName(exec,[Default]))) invalidates 1 classes due to The PegParser has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(many,[Default]), UsedName(peg_parse,[Default]), UsedName(parse,[Default]), UsedName(exec,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(PegParser)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from PegPackratParser...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(PegPackratParser)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(PegPackratParser)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of GpegParser: Set(UsedName(peg_parse,[Default]), UsedName(parse,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(PegPackratParser,ModifiedNames(changes = UsedName(renew_id_trees,[Default]), UsedName(memorized,[Default]), UsedName(peg_parse,[Default]), UsedName(many,[Default]), UsedName(exec,[Default]), UsedName(fold,[Default]), UsedName(disamb,[Default]), UsedName(parse,[Default]), UsedName(amb_memorized,[Default]), UsedName(renew_id,[Default]), UsedName(disambiguity,[Default]), UsedName(amb_parse,[Default]), UsedName(renew_id_tree,[Default]))) invalidates 2 classes due to The PegPackratParser has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(renew_id_trees,[Default]), UsedName(memorized,[Default]), UsedName(peg_parse,[Default]), UsedName(many,[Default]), UsedName(exec,[Default]), UsedName(fold,[Default]), UsedName(disamb,[Default]), UsedName(parse,[Default]), UsedName(amb_memorized,[Default]), UsedName(renew_id,[Default]), UsedName(disambiguity,[Default]), UsedName(amb_parse,[Default]), UsedName(renew_id_tree,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(PegPackratParser)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(GpegParser)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from Tree...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(Tree)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(Tree)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser.ParseResult: Set(UsedName(asInstanceOf,[Default]), UsedName(eq,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(==,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegParser: Set(UsedName(asInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Leaf,[Default]), UsedName(Node,[Default]), UsedName(==,[Default]), UsedName(Tree,[Default, PatMatTarget]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser: Set(UsedName(asInstanceOf,[Default]), UsedName(AmbNode,[Default]), UsedName(ne,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(Leaf,[Default]), UsedName(Node,[Default]), UsedName(==,[Default]), UsedName(Tree,[Default, PatMatTarget]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegParser.ParserContext: Set(UsedName(Tree,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser.AmbParseResult: Set(UsedName(asInstanceOf,[Default]), UsedName(eq,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(==,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of PegPackratParser.Memo: Set(UsedName(Tree,[Default]), UsedName(toString,[Default]))[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following modified names cause invalidation of GpegParser: Set(UsedName(asInstanceOf,[Default]), UsedName(isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(Tree,[Default, PatMatTarget]))[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(Tree,ModifiedNames(changes = UsedName(asInstanceOf,[Default]), UsedName(AmbNode,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName(clone,[Default]), UsedName(notify,[Default]), UsedName(ne,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(equals,[Default]), UsedName(Leaf,[Default]), UsedName(Node,[Default]), UsedName($isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]))) invalidates 8 classes due to The Tree has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(asInstanceOf,[Default]), UsedName(AmbNode,[Default]), UsedName(synchronized,[Default]), UsedName(##,[Default]), UsedName(wait,[Default]), UsedName(clone,[Default]), UsedName(notify,[Default]), UsedName(ne,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(Tree,[Default]), UsedName(isInstanceOf,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(toString,[Default]), UsedName(!=,[Default]), UsedName(equals,[Default]), UsedName(Leaf,[Default]), UsedName(Node,[Default]), UsedName($isInstanceOf,[Default]), UsedName(==,[Default]), UsedName(finalize,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(Tree)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> by member reference: Set(PegPackratParser.ParseResult, PegParser, PegPackratParser, PegParser.ParserContext, PegPackratParser.AmbParseResult, PegPackratParser.Memo, GpegParser)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mNew invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set(GpegParser)[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set(GpegParser)[0m
[0m[[0m[0mdebug[0m] [0m[0mPreviously invalidated, but (transitively) depend on new invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll newly invalidated classes after taking into account (previously) recompiled classes:Set(GpegParser)[0m
[0m[[0m[0minfo[0m] [0m[0mCompiling 1 Scala source to /Users/shonanking/lab/GPEG/target/scala-2.12/classes ...[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.12:1.0.5:compile for Scala 2.12.4[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.12:1.0.5:compile for Scala 2.12.4[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] Running cached compiler 5745d49d for Scala compiler version 2.12.4[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] The Scala compiler is invoked with:[0m
[0m[[0m[0mdebug[0m] [0m[0m	-deprecation[0m
[0m[[0m[0mdebug[0m] [0m[0m	-feature[0m
[0m[[0m[0mdebug[0m] [0m[0m	-unchecked[0m
[0m[[0m[0mdebug[0m] [0m[0m	-Xlint[0m
[0m[[0m[0mdebug[0m] [0m[0m	-bootclasspath[0m
[0m[[0m[0mdebug[0m] [0m[0m	/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/sunrsasign.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/jre/classes:/Users/shonanking/.sbt/boot/scala-2.12.4/lib/scala-library.jar[0m
[0m[[0m[0mdebug[0m] [0m[0m	-classpath[0m
[0m[[0m[0mdebug[0m] [0m[0m	/Users/shonanking/lab/GPEG/target/scala-2.12/classes:/Users/shonanking/.ivy2/cache/org.scalactic/scalactic_2.12/bundles/scalactic_2.12-3.0.4.jar:/Users/shonanking/.sbt/boot/scala-2.12.4/lib/scala-reflect.jar:/Users/shonanking/.ivy2/cache/org.scala-lang.modules/scala-parser-combinators_2.12/bundles/scala-parser-combinators_2.12-1.0.6.jar[0m
[0m[[0m[0mdebug[0m] [0m[0mScala compilation took 2.83461135 s[0m
[0m[[0m[0minfo[0m] [0m[0mDone compiling.[0m
[0m[[0m[0mdebug[0m] [0m[0mNew invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mPreviously invalidated, but (transitively) depend on new invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll newly invalidated classes after taking into account (previously) recompiled classes:Set()[0m
